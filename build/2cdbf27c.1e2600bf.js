(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{132:function(e,t,r){"use strict";r.r(t),t.default=r.p+"assets/images/merge-41685e8e9dc15ee02a18fb0d5305a4c3.svg"},71:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return i})),r.d(t,"metadata",(function(){return c})),r.d(t,"rightToc",(function(){return s})),r.d(t,"default",(function(){return p}));var n=r(3),a=r(7),o=(r(0),r(91)),i={id:"merge",title:"Merge"},c={unversionedId:"core/reactive/merge",id:"core/reactive/merge",isDocsHomePage:!1,title:"Merge",description:"Category: Combinator",source:"@site/docs\\core\\reactive\\merge.md",slug:"/core/reactive/merge",permalink:"/docs/core/reactive/merge",editUrl:"https://github.com/spewil/bonsai-rx-docs/edit/master/website/docs/core/reactive/merge.md",version:"current",sidebar:"docs",previous:{title:"DistinctUntilChanged",permalink:"/docs/core/reactive/distinct_until_changed"},next:{title:"Skip",permalink:"/docs/core/reactive/skip"}},s=[],l={rightToc:s};function p(e){var t=e.components,i=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},l,i,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Category"),": Combinator"),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Brief"),": Merges any number of observable sequences iinto a single observable sequence."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Input"),": Accepts many input types (single elements, tuples, arrays) as long as more than one input is supplied and all are of the same type"),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Output"),": Same type as input, keeping the same shape (e.g. two ",Object(o.b)("inlineCode",{parentName:"p"},"1 x N")," arrays gives a ",Object(o.b)("inlineCode",{parentName:"p"},"1 x N")," array that alternates between the two inputs)"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"Merge")," operator allows you to combine the output of multiple observables so that you can treat them as if they were the same observable. This is done by merging all the notifications from all the input sequences into a single sequence, as described in the marble diagram below."),Object(o.b)("p",null,Object(o.b)("img",{alt:"Merge operator",src:r(132).default})),Object(o.b)("p",null,"The merged observable will terminate successfully when all the input sequences have terminated successfully, or exceptionally as soon as any sequence raises an error."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Common errors"),": ",Object(o.b)("inlineCode",{parentName:"p"},"Build Error: No method overload found for the given arguments."),"\nThe supplied inputs might be of different types."))}p.isMDXComponent=!0},91:function(e,t,r){"use strict";r.d(t,"a",(function(){return u})),r.d(t,"b",(function(){return d}));var n=r(0),a=r.n(n);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function c(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=a.a.createContext({}),p=function(e){var t=a.a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):c(c({},t),e)),r},u=function(e){var t=p(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},m=a.a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,i=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=p(r),m=n,d=u["".concat(i,".").concat(m)]||u[m]||b[m]||o;return r?a.a.createElement(d,c(c({ref:t},l),{},{components:r})):a.a.createElement(d,c({ref:t},l))}));function d(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,i=new Array(o);i[0]=m;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:n,i[1]=c;for(var l=2;l<o;l++)i[l]=r[l];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,r)}m.displayName="MDXCreateElement"}}]);